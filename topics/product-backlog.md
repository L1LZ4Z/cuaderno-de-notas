# Product Backlog

## Índice

 - [Sofware Enginnering 10th Edition - Ian Sommerville](#1)
   - [User Stories: Scenarios y Acceptance Criteria](#1.1)
 - [User Stories Applied for Agile Development - Mike Cohn](#2)
   - [Elicitación de requisitos](#2.1)
   - [Elicitación de requisitos como un proceso contínuo](#2.2)
   - [Slicing para user stories](#2.3)

## Notas

<h3 id="1.1">Sofware Enginnering 10th Edition - Ian Sommerville</h3>

<h4 id="1.2">User Stories: Scenarios y Acceptance Criteria (p. 119)</h4>

Las historias deben incluir en sus criterios de aceptación:
 - Lo que el usuario y el sistema esperan (como input o precondición) al empezar el escenario
 - El flujo normal o ideal (happy path)
 - Las cosas que pueden fallar y como se maneja el error (unhappy paths)
 - El estado de finalización del sistema al concluir

 <h3 id="2">User Stories Applied for Agile Development - Mike Cohn</h3>

 <h4 id="2.1">Elicitación de requisitos (p. 43)</h4>

 La elicitación de requisitos es como pescar con red. Los requisitos se encuentran allí afuera esperando a ser capturados. Depende de nosotros escoger la red adecuada (instrumentos o métodos de elicitación) para poder capturarlos.

 <h4 id="2.2">Elicitación de requisitos como un proceso contínuo (p. 44)</h4>

 Los equipos ágiles entienden que es imposible capturar todos los requisitos "en una sola pesca".

<h4 id="2.3">Slicing para user stories (p.76)</h4>

Cuando dividimos una épica en historias de usuario, debemos pensar en el tamaño y alcance de cada historia como el de una tajada de torta. No se cortan solo por capas (por ejemplo, backend o frontend), sino desde el exterior hasta el centro. Cada historia de usuario debe ser una pieza que incluya un poco de cada parte necesaria para **entregar valor funcional completo al usuario final**.

Por tanto, una historia de usuario bien definida en definitiva podría incluir cambios tanto en el front-end como en el back-end.
